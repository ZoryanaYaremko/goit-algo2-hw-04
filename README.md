# Домашнє завдання до модуля “Просунуті структури для оптимізації та пошуку” (теми 3 та 4)
# Завдання 1. Алгоритм максимального потоку (Едмондс–Карп)

## Мета
Побудувати модель логістичної мережі постачання товарів від терміналів до магазинів через склади та визначити оптимальний (максимальний) потік у системі.

## Початкові дані
- У мережі два термінали (**Термінал 1**, **Термінал 2**), чотири склади (**Склад 1–4**) і 14 магазинів.  
- Між вузлами задані ребра з певною пропускною здатністю (одиниць товару).  
- Алгоритм пошуку максимального потоку — **Едмондс-Карп** (модифікація методу Форда-Фалкерсона на основі BFS).

## Результат розрахунку
```
Максимальний сумарний потік: 115 одиниць
```

| Термінал | Разом по терміналу |
|-----------|-------------------|
| Термінал 1 | **60** |
| Термінал 2 | **55** |

| Магазин | Разом по магазину |
|----------|-------------------|
| Магазин 6 | 5 |
| Магазин 2 | 10 |
| Магазин 5 | 10 |
| Магазин 8 | 10 |
| Магазин 11 | 10 |
| Магазин 1 | 15 |
| Магазин 4 | 15 |
| Магазин 10 | 20 |
| Магазин 7 | 20 |

(інші магазини — 3, 9, 12, 13, 14 — не отримали постачання, оскільки потік через відповідні склади вичерпано).

## Аналіз результатів

**1️. Які термінали забезпечують найбільший потік товарів до магазинів?**  
Найбільший потік проходить через **Термінал 1 (60 од.)**, трохи менший — через **Термінал 2 (55 од.)**.  
Обидва термінали працюють майже з максимально можливою продуктивністю, що свідчить про балансоване завантаження системи.

**2️. Які маршрути мають найменшу пропускну здатність і як це впливає на загальний потік?**  
Найвужчі місця — ребра між терміналами та складами:  
- **Термінал 1 → Склад 1 (25 од.)**  
- **Термінал 1 → Склад 2 (20 од.)**  
- **Термінал 2 → Склад 4 (30 од.)**  
- **Термінал 2 → Склад 3 (15 од.)**  
Ці обмеження не дозволяють складам повністю реалізувати потенціал своїх вихідних каналів до магазинів, тому частина магазинів залишилась без постачання.

**3️. Які магазини отримали найменше товарів і чи можна збільшити їх постачання?**  
Найменше отримали **Магазини 6 (5 од.)**, **2, 5, 8, 11 (по 10 од.)**, а також 3, 9, 12–14 — 0.  
Для підвищення постачання необхідно збільшити пропускну здатність ребер:  
- **Термінал 1 → Склад 1** — щоб живити Магазин 3;  
- **Термінал 1/2 → Склад 2** — щоб підняти Магазин 6;  
- **Термінал 1/2 → Склад 3** — для Магазинів 8–9;  
- **Термінал 2 → Склад 4** — для Магазинів 12–14.

**4️. Чи є вузькі місця, які можна усунути для підвищення ефективності мережі?**  
Так, головні “пляшкові горлечка” — **входи складів**. Виходи (склади→магазини) мають більшу сумарну пропускну здатність, тому додаткове збільшення місткості термінальних ребер одразу підвищить загальний потік.  
Підняття ліміту хоча б на 10–15 одиниць для Складів 2 і 4 дозволить покрити магазини, що зараз не отримують товарів.

## Висновок
Алгоритм **Едмондса-Карпа** дозволив знайти **оптимальний розподіл товарних потоків (115 одиниць)** у межах заданих обмежень.  
Система функціонує збалансовано, але подальше зростання можливе лише шляхом **збільшення пропускних здатностей між терміналами та складами**.  
Отримані результати демонструють реальну поведінку логістичної мережі, де саме “входи” складів стають критичними точками для підвищення продуктивності.
## Скріншоти:
<img width="375" height="57" alt="image" src="https://github.com/user-attachments/assets/1270dc3f-6d51-4eb5-9264-bf64c467858e" />
<img width="524" height="418" alt="image" src="https://github.com/user-attachments/assets/a99e91e8-8a9f-44ce-831e-d8369d5dc114" />
<img width="366" height="250" alt="image" src="https://github.com/user-attachments/assets/8e460c5e-9300-4f5e-8bf1-9f9e52cf192d" />

# Завдання 2. Розширення функціоналу префіксного дерева (Trie)

## Мета
Реалізувати два методи для класу `Trie`:
- `count_words_with_suffix(pattern) -> int` — підрахунок слів, що закінчуються заданим суфіксом;
- `has_prefix(prefix) -> bool` — перевірка наявності хоча б одного слова з заданим префіксом.

## Інтерфейс класу `Homework`
```python
class Homework(Trie):
    def count_words_with_suffix(self, pattern) -> int: ...
    def has_prefix(self, prefix) -> bool: ...
```
- Всі параметри — **рядки**; за іншого типу кидається `TypeError`.
- Враховується **регістр**.
- Обидва методи працюють ефективно на великих наборах.

## Основні ідеї реалізації
- **Префіксний індекс**: словник `_prefix_counts: prefix -> count`. Дозволяє відповідати на `has_prefix` за **O(1)**.
- **Реверсний Trie** для суфіксів: `_rev_root`. Для `count_words_with_suffix(pattern)` проходимо по символах `pattern` у зворотному порядку і повертаємо `subtree_count` вершини — **O(|pattern|)**.
- Збереження унікальних слів у `_words`, щоб не дублювати індексацію при повторних `put`.

## Обробка помилок
- `TypeError` при не-рядкових параметрах (`None`, числа, списки тощо).
- Порожній рядок:  
  - `has_prefix("")` → `True`, якщо в Trie є хоч одне слово;  
  - `count_words_with_suffix("")` → кількість усіх унікальних слів.

## Тести (фрагменти з ноутбука)
- Базові перевірки з умови — **пройдені**.
- Розширені перевірки (регістр/крайові/помилки) — **пройдені**.
- Стрес‑тест ~20k випадкових слів: запити виконуються за **десятки мікросекунд** (приклад запуску: `has_prefix('axi') ≈ 0.07 мс`, `count_words_with_suffix('csn') ≈ 0.06 мс`).

## Складність
- `put(word)` — O(L) + O(L) на індексацію префіксів + O(L) на вставку в реверсний Trie (L — довжина слова).
- `has_prefix(prefix)` — **O(1)** по часовій; пам'ять — O(сумарної кількості префіксів).
- `count_words_with_suffix(pattern)` — **O(|pattern|)** по часовій; пам'ять — O(загальної кількості символів у словах) на реверсний Trie.

## Висновок
Запропонована реалізація задовольняє вимоги ТЗ: коректність, обробка помилок, урахування регістру та ефективність на великих наборах даних. 
`has_prefix` працює за O(1), а `count_words_with_suffix` — за O(|pattern|), що робить рішення придатним для масштабних задач пошуку.



